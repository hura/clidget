* Clidget

*Clidget is a lightweight CLJS state utility that allows you to build
UIs through small, composable 'widgets'.*

Clidget's API is still young (read: pre-alpha) and subject to change.

** Getting started

Add the following to your =project.clj=

#+BEGIN_SRC clojure
  [jarohen/clidget "0.1.0-SNAPSHOT"]
#+END_SRC

and the following to your CLJS =:require=:

#+BEGIN_SRC clojure
  (:require [clidget.widget :refer [defwidget] :include-macros true])
#+END_SRC

** Clidget's Design Aims:

When writing Clidget, I had the following aims:

- *Do one thing, and do it well* - Clidget does not aim to be an 'all
  batteries included' framework. In particular, it leaves you free to
  choose how to render DOM elements (do you prefer Hiccup-like
  libraries? Mustache templating?) and how to handle events. 

  Clidget is good at knowing when to re-render widgets, the rest is up
  to you.
- *No Magic* - 'magic' is great when it's a small example ('wow, that's
  magic! How did they do that so concisely?!') but not so great when
  the magic stops working, you stray off the beaten track, or
  encounter an incomprehensible error.

  Clidget uses vanilla Clojure data structures and functions, and is
  mostly based around standard Clojure watches on atoms. It expects
  you to return standard JS DOM elements (which you can pass to other
  JS libraries as-they-are)
  
- *Immutability where possible* - it goes without saying that
  immutable values are far easier to reason about and test. Even
  though the DOM is inherently mutable, the widgets that you write are
  functions that take in values and return a value (and can be tested
  as such).

- *Preserve Clojure's composability* - Clojure is great at composing
  small libraries together (I believe it's one of Clojure's core
  strengths) so let's ensure that you can use other libraries easily
  (even other JS libraries).

** The 'back of an envelope' story:

Clidget is under development at the moment - until this README is
fully written you can check out the example in the =clidget-sample=
directory, or the TodoMVC example in the =todomvc= directory - run
=lein dev= to start them.

The basic premise is that =clidget.widget/defwidget= watches the
application state for you, and invites you to re-render the component
when any of the state changes. The values destructured in the first
param are just that - values - that you can use to build a DOM
element:

#+BEGIN_SRC clojure
  (defwidget counter-widget [{:keys [counter]} events-ch]
    (node
     [:div
      [:h2 "counter is now: " counter]
      [:p
       (doto (node [:button.btn "Inc counter"])
         (d/listen! :click #(a/put! events-ch :inc-counter)))]]))
#+END_SRC

You are free to use whichever DOM rendering/events handling libraries
you choose (I'm not going to impose a particular style on you). If
you're stuck with where to get started with these, I highly recommend
Dommy and Clojure's own core.async!

To include a widget in the page, call it (it's just a function!), and
provide it with the *atoms* that it needs to watch:

#+BEGIN_SRC clojure
  (set! (.-onload js/window)
        (fn []
          (let [!counter (atom 0)
                events-ch (doto (a/chan)
                            (watch-events! !counter))]
  
            (d/replace-contents! (.-body js/document)
                                 (node [:h2 {:style {:margin-top "1em"}}
                                        (counter-widget {:!counter !counter} events-ch)])))))
#+END_SRC

=watch-events!= then needs to watch any events coming out of the
widget, and update the state accordingly:

#+BEGIN_SRC clojure
  (defn watch-events! [events-ch !counter]
    (go-loop []
      (when-let [event (a/<! events-ch)]
        (when (= event :inc-counter)
          (swap! !counter inc))
        (recur))))
#+END_SRC

** That's all for now

I'm currently in the process of writing up a more comprehensive
README, but please let me know in the meantime if you have any
comments, suggestions or ideas! 

I can be reached through GitHub, or Twitter at [[https://twitter.com/jarohen][@jarohen]].

Thanks!

James
