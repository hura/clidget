* Clidget

*Clidget is a lightweight CLJS state utility that allows you to build
UIs through small, composable 'widgets'.*

** Getting started

Add the following to your =project.clj=

#+BEGIN_SRC clojure
  [jarohen/clidget "0.1.0-SNAPSHOT"]
#+END_SRC

and the following to your CLJS =:require=:

#+BEGIN_SRC clojure
  (:require [clidget.widget :refer [defwidget] :include-macros true])
#+END_SRC

** Clidget's Rationale:

When writing Clidget, I had the following aims:

- *Do one thing, and do it well* - Clidget does not aim to be an 'all
  batteries included' framework. In particular, it leaves you free to
  choose how to render DOM elements (do you prefer Hiccup-like
  libraries? Mustache templating?) and how to handle events. 

  Clidget is good at knowing when to re-render widgets, the rest is up
  to you.

- *No Magic* - 'magic' is great when it's a small example ('wow, that's
  magic! How did they do that so concisely?!') but not so great when
  the magic stops working, you stray off the beaten track, or
  encounter an incomprehensible error.

  Clidget uses vanilla Clojure data structures and functions, and is
  mostly based around standard Clojure watches on atoms. It expects
  you to return standard JS DOM elements (which you can pass to other
  JS libraries as-they-are)
  
- *Immutability where possible* - it goes without saying that
  immutable values are far easier to reason about and test. 

  Even though the DOM is inherently mutable, the widgets that you
  write are functions that take in values and return a value (and can
  be tested as such).

- *Preserve Clojure's composability* - Clojure is great at composing
  small libraries together (I believe it's one of Clojure's core
  strengths) so let's ensure that you can use other libraries easily
  (even other JS libraries).

** Example Clidget applications

If you want to dive straight into examples, there are two in the repo:
a simple counter (in the =clidget-sample= directory), and a [[http://todomvc.com/][TodoMVC]]
example in the =todomvc= directory.

You can run the examples by cloning the repo, and running =lein dev=.

** The 'back of an envelope' story:

The basic premise is that =clidget.widget/defwidget= watches the
application state for you, and invites you to re-render the component
when any of the state changes. The values destructured in the first
param are just that - values - that you can use to build a DOM
element:

#+BEGIN_SRC clojure
  (defwidget counter-widget [{:keys [counter]} events-ch]
    (node
     [:div
      [:h2 "counter is now: " counter]
      [:p
       (doto (node [:button.btn "Inc counter"])
         (d/listen! :click #(a/put! events-ch :inc-counter)))]]))
#+END_SRC

You are free to use whichever DOM rendering/events handling libraries
you choose (I'm not going to impose a particular style on you). If
you're stuck with where to get started with these, I highly recommend
[[https://github.com/Prismatic/dommy][Dommy]] and Clojure's own [[https://github.com/clojure/core.async][core.async]]!

To include a widget in the page, call it (it's just a function!), and
provide it with the *atoms* that it needs to watch:

#+BEGIN_SRC clojure
  (set! (.-onload js/window)
        (fn []
          (let [!counter (atom 0)
                events-ch (doto (a/chan)
                            (watch-events! !counter))]
  
            (d/replace-contents! (.-body js/document)
                                 (node [:h2 {:style {:margin-top "1em"}}
                                        (counter-widget {:!counter !counter} events-ch)])))))
#+END_SRC

Note the exclamation mark in =:!counter= that you pass to
=counter-widget= - this informs Clidget that you're passing an
atom. (If you don't put an exclamation mark in, Clidget will treat it
as a value - more on this later.)

To complete the example, =watch-events!= then needs to watch any
events coming out of the widget, and update the state accordingly:

#+BEGIN_SRC clojure
  (defn watch-events! [events-ch !counter]
    (go-loop []
      (when-let [event (a/<! events-ch)]
        (when (= event :inc-counter)
          (swap! !counter inc))
        (recur))))
#+END_SRC

** Diving into 'defwidget'



** Feedback/suggestions/ideas/bug reports/PRs etc

If you've made it this far through the README (congratulations!), I'd
really appreciate your feedback and suggestions.

I can be reached in the traditional GitHub ways, or on Twitter at
[[https://twitter.com/jarohen][@jarohen]].

Thanks!

James

** License

Copyright Â© 2014 James Henderson

Distributed under the Eclipse Public License, the same as Clojure
